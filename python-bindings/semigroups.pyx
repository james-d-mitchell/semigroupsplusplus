#cython: infer_types=True, embedsignature=True
"""
Python bindings for the libsemigroups C++ library.

`libsemigroups <https://github.com/james-d-mitchell/libsemigroups/>`_
is a C++ mathematical library for computing with finite `semigroups
<https://en.wikipedia.org/wiki/Semigroup>`_. This Cython module
provides bindings to call it from Python.

We construct the semigroup generated by `0` and `-1`::

    >>> from semigroups import Semigroup
    >>> S = Semigroup([0,-1])
    >>> S.size()
    3

We construct the semigroup generated by `0` and complex number `i`::

    >>> S = Semigroup([0, 1j])
    >>> S.size()
    5
"""
from libc.stdint cimport uint16_t
from libc.stdint cimport uint32_t
from libcpp.vector cimport vector
cimport semigroups_cpp as cpp
from libcpp cimport bool


#Add _handle.right_cayley_graph
#Add Gabow's algm
#Change _handle to _cpp_semigroup or _cpp_trans,.. etc

#cdef class MyCppElement(cpp.Element):
#    pass

cdef class __dummyClass:
    def __init__(self):
        pass
   

cdef class Element:# Add identity
    """
    An abstract base class for handles to libsemigroups elements.

    Any subclass shall implement an ``__init__`` method which
    initializes _handle.

    .. WARNING::

        For now, the ``__init__`` method should also accept to be
        called with ``None`` as argument, in which case it *should
        not* initialize the handle.

        This is used by ``new_from_handle``.

    .. TODO::

        Find a better protocol to create an instance from a class and
        a handle.
    """
    cdef cpp.Element* _handle

    def __cinit__(self):
        self._handle = NULL

    def __dealloc__(self):
        """
        Deallocate the handle of ``self``.

        TESTS::

            >>> from semigroups import Semigroup, PythonElement, Transformation
            >>> x = PythonElement(-1)
            >>> x = 3

            >>> x = Transformation([1,2,0])
            >>> del x
        """
        if self._handle != NULL:
            self._handle[0].really_delete()
            del self._handle

    def __mul__(Element self, Element other):
        """
        Return the product of ``self`` and ``other``.

        EXAMPLES::

            >>> from semigroups import Semigroup, PythonElement, Transformation
            >>> x = Transformation([2,1,1])
            >>> y = Transformation([2,1,0])
            >>> x * y
            [0, 1, 1]
            >>> y * x
            [1, 1, 2]
        """
        if not isinstance(self, type(other)):
            raise TypeError('Elements must be same type')
        cdef cpp.Element* product = self._handle.identity()
        if self._handle.degree() != other._handle.degree():
            raise ValueError('Element degrees must be equal')
        product.redefine(self._handle, other._handle)
        return self.new_from_handle(product)
	
    def __pow__(self, power, modulo):#It works, but don't understand why it needs 'modulo' argument aal20
        if not(isinstance(power, int)):
            raise TypeError('Can only power by int')
        if power < 0:
            raise ValueError('Power must be positive')

        #Converts power to binary, then constructs element to the power of 2^n for needed n.
        binaryString = bin(power - 1)[2:]
        powerOf2List = [self]
        for x in binaryString:
            powerOf2List.append(powerOf2List[-1].__mul__(powerOf2List[-1]))
        output = self 

	#generates answer using element to the power of powers of 2 (binary tells you which ones to multiply)
        for i in range(len(binaryString)):
            if binaryString[i] == "1":
                 output=output.__mul__(powerOf2List[i])
        return output

        '''
        >>> from semigroups import Semigroup, PythonElement, Transformation
        >>> y=Transformation([2,1,0])
        >>> y**2
        Transformation([0, 1, 2])
        >>> y*y
        Transformation([0, 1, 2])'''
    
    def __richcmp__(Element self, Element other, int op):
        if op == 0:
            return self._handle[0] < other._handle[0]
        elif op == 1:
            return self._handle[0] < other._handle[0] or self._handle[0] == other._handle[0]
        elif op == 2:
            return self._handle[0] == other._handle[0]
        elif op == 3:
            return not self._handle[0] == other._handle[0]
        elif op == 4:
            return not (self._handle[0] < other._handle[0] or self._handle[0] == other._handle[0])
        elif op == 5:
            return not self._handle[0] < other._handle[0]

    
    # TODO: Make this a class method
    cdef new_from_handle(self, cpp.Element* handle):
        """
        Construct a new element from a specified handle and with the
        same class as ``self``.
        """
        cdef Element result = self.__class__(__dummyClass)
        result._handle = handle[0].really_copy()
        return result

    def degree(self):
        return self._handle.degree()

cdef class Transformation(Element):

#Python googlestyle docstrings for examples
    """
    A class for handles to libsemigroups transformations.

    A transformation f is just a function defined on the whole of 
    {0, 1, ..., n - 1} for some integer n called the degree of f. A
    transformation is stored as a vector of the images of {0, 1, ..., n   -1},
    i.e. [(0)f, (1)f, ..., (n - 1)f].

    Args:
        List (list): Image list of the Transformation when applied to [0, 1, ..., n]

    Raises:
        

    Example:
        >>> from semigroups import Transformation
        >>> Transformation([2, 1, 1])
        Transformation([2, 1, 1])        
    """
    def __init__(self, List):
        
        if List is not __dummyClass:
            for i in List:
                if not isinstance(i, int):
                    raise TypeError('Image list must only contain ints')
                if i < 0:
                    raise ValueError('Image list cannot contain negative values')
            if not isinstance(List, list):
                raise TypeError('Input must be a list')
            if max(List) + 1 > len(List):
                raise ValueError('Not a valid Transformation')
            self._handle = new cpp.Transformation[uint16_t](List)

    def __iter__(self):
        """
        Function for iterating through the image list of 'self'.

        Args:
            None

        Returns:
            generator: A generator of the image list

        Example:
            >>> from semigroups import Transformation
            >>> list(Transformation([1, 2, 0]))
            [1, 2, 0]
        """
        cdef cpp.Element* e = self._handle
        e2 = <cpp.Transformation[uint16_t] *>e
        for x in e2[0]:
            yield x

    def __repr__(self):
        """
        Function for printing a string representation of 'self'.
        
        Args:
            None

        Returns
            str: 'Transformation' then the image list in brackets

        Example:
            >>> from semigroups import Transformation
            >>> Transformation([1, 2, 0])
            Transformation([1, 2, 0])
        """
        return "Transformation(" + str(list(self)) + ")"

cdef class PartialPerm(Element):
    """
    A class for handles to libsemigroups partial perm.
    """
    
    cdef list _domain,_range
    
    def __init__(self, *args):

        if len(args) == 1:
            if args[0] == __dummyClass:
                return
            self._handle = new cpp.PartialPerm[uint16_t](list(args)[0])
        else:
            if not isinstance(args[0], list):
                raise TypeError('Domain must be a list')
            if not isinstance(args[1], list):
                raise TypeError('Range must be a list')
            if not isinstance(args[2], int):
                raise TypeError('Degree must be an int')

            self._domain, self._range, _degree = args[0], args[1], args[2]

            if _degree < 0:
                raise ValueError('Degree must be non-negative')
            if len(self._domain) != len(self._range):
                raise ValueError('Domain and range must be same size')
            if len(self._domain) != 0:
                if not(max(self._domain) < _degree and max(self._range) < _degree):
                    raise ValueError('The max of the domain and range must be strictly less than the degree')

            n = len(self._domain)
            imglist = [65535] * _degree

            for i in range(n):
                if not (isinstance(self._domain[i], int) and isinstance(self._range[i], int)):
                    raise TypeError('Elements of domain and range must be ints')
                if self._domain[i] < 0 or self._range[i] < 0:
                    raise ValueError('Elements of domain and range must be non-negative')
                
                #Ensures range and domain have no repeats
                if self._range[i] in imglist:
                    raise ValueError('Range cannot have repeats')
                if self._domain.count(i) > 1:
                    raise ValueError('Domain cannot have repeats')

            for i in range(n):
                imglist[self._domain[i]] = self._range[i]

            self._handle = new cpp.PartialPerm[uint16_t](imglist)

    def _generator(self):
        cdef cpp.Element* e = self._handle
        e2 = <cpp.PartialPerm[uint16_t] *>e
        for x in e2[0]:
            yield x

    def init_dom_ran(self):
        if self._domain == None or self._range == None:
            L = self._generator()
            self._domain, self._range = [], []
            for i in range(self.degree()):
                if L[i] != 65535 and L[i] != -1:
                    self._domain.append(i)
                    self._range.append(L[i])

    def __repr__(self):
        """
        Return a string representation of `self`.

        EXAMPLES::

            >>> from semigroups import *
	    >>> PartialPerm([1,4,2],[2,3,4],6)
	    PartialPerm([1, 4, 2], [2, 3, 4], 6)


        """


        self.init_dom_ran_deg()
        return ("PartialPerm(%s, %s, %s)"%(self._domain, self._range, self.degree())).replace('65535', '-1')

    def rank(self):
        cdef cpp.Element* e = self._handle
        e2 = <cpp.PartialPerm[uint16_t] *>e
        return e2.crank()

    def domain(self):
        self.init_dom_ran()
        return self._domain

    def range(self):
        self.init_dom_ran()
        return self._range

cdef class Bipartition(Element):
    """
    A class for handles to libsemigroups bipartition.
    """

    cdef list _blocks

    def __init__(self, *args):
        if args[0] is not __dummyClass:

            n = 1

            for sublist in args:
                if not isinstance(sublist, list):
                    raise TypeError('Arguments must be lists')
                n = max(max(sublist), n)

            #Note that this assert ensures all entries are non-zero ints
            if set().union(*args) != set(range(1, n + 1)).union(set(range(-1, -n - 1, -1))):
                raise ValueError('Not a valid Biparition')

            argsCopy = []
            self._blocks = []

            for sublist in args:
                self._blocks.append(sublist[:])
                argsCopy.append(sublist[:])

            for sublist in argsCopy:
                for i in range(len(sublist)):
                    entry = sublist[i]
                    sublist[i] = n + abs(entry) - 1 if entry < 0 else entry - 1
                sublist.sort()

            argsCopy.sort()
            output = [0] * n * 2
            for i, sublist in enumerate(argsCopy):
                for j in sublist:
                    output[j] = i

            self._handle = new cpp.Bipartition(output)


    def _generator(self):
        cdef cpp.Element* e = self._handle
        e2 = <cpp.Bipartition *>e
        for x in e2[0]:
            yield x

    def init_blocks(self):
        if self._blocks is None:
            self._blocks = []
            gen = self._generator
            i = 0
            n = 2 * self.degree() + 1
            while i in gen:
                block = []
                for ind,j in enumerate(gen):
                    if j == i:
                        if ind < n/2:
                            block.append(ind + 1)
                        else:
                            block.append(n/2 - ind - 1)
                self._blocks.append(block)
                i += 1
                            
    def blocks(self):
        self.init_blocks()
        return self._blocks

    def numberOfBlocks(self):
        cdef cpp.Element* e = self._handle
        e2 = <cpp.Bipartition *>e
        return e2.const_nr_blocks()

    def block(self, element):
        n = self.degree()
        if not element in set(range(1, n + 1)).union(set(range(-1, -n - 1, -1))):
            raise ValueError('Element not in Bipartition')
        
        if element < 1:
            element = n - element - 1
        else:
            element -= 1
        
        cdef cpp.Element* e = self._handle
        e2 = <cpp.Bipartition *>e
        return e2.block(element)

    def isTransverseBlock(self, index):
        if not isinstance(index, int):
            raise TypeError("Index must be 'int' type")

        if index < 0 or abs(index) > self.numberOfBlocks() - 1:
            raise IndexError('Index out of range')
        cdef cpp.Element* e = self._handle
        e2 = <cpp.Bipartition *>e
        return e2.is_transverse_block(index)

    def __repr__(self):
        self.init_blocks()
        return 'Bipartition(%s)'%self._blocks.__repr__()[1:-1]

cdef class PythonElement(Element):
    """
    A class for handles to libsemigroups elements that themselves wrap
    back a Python element

    EXAMPLE::

        >>> from semigroups import Semigroup, PythonElement
        >>> x = PythonElement(-1); x
        -1

        >>> Semigroup([PythonElement(-1)]).size()
        2
        >>> Semigroup([PythonElement(1)]).size()
        1
        >>> Semigroup([PythonElement(0)]).size()
        1
        >>> Semigroup([PythonElement(0), PythonElement(-1)]).size()
        3

        x = [PythonElement(-1)]
        x = 2

        sage: W = SymmetricGroup(4)
        sage: pi = W.simple_projections()
        sage: F = FiniteSetMaps(W)
        sage: S = Semigroup([PythonElement(F(p)) for p in pi])
        sage: S.size()
        23

    TESTS::

        Testing reference counting::

            >>> s = "UN NOUVEL OBJET"
            >>> sys.getrefcount(s)
            2
            >>> x = PythonElement(s)
            >>> sys.getrefcount(s)
            3
            >>> del x
            >>> sys.getrefcount(s)
            2
    """
    def __init__(self, value):
        if value is not None:
            self._handle = new cpp.PythonElement(value)

    def get_value(self):
        """

        """
        return (<cpp.PythonElement *>self._handle).get_value()

    def __repr__(self):
        return repr(self.get_value())

cdef class Semigroup:# Add asserts
    """
    A class for handles to libsemigroups semigroups

    EXAMPLES:

    We construct the symmetric group::

        >>> from semigroups import Semigroup, Transformation
        >>> S = Semigroup([Transformation([1,2,0]),Transformation([2,1,0])])
        >>> S.size()
        6
    """
    cdef cpp.Semigroup* _handle      # holds a pointer to the C++ instance which we're wrapping
    cdef Element _an_element

    def __cinit__(self):
        self._handle = NULL

    def __init__(self, generators):
        """
        TESTS::

            >>> Semigroup([1, Transformation([1,0])])
            ...
            TypeError: all generators should have the same type
        """
        generators = [g if isinstance(g, Element) else PythonElement(g)
                      for g in generators]
        if not len({type(g) for g in generators}) <= 1:
            raise TypeError("all generators should have the same type")
        cdef vector[cpp.Element *] gens
        for g in generators:
            gens.push_back((<Element>g)._handle)
        self._handle = new cpp.Semigroup(gens)
        self._an_element = generators[0]

    def __dealloc__(self):
        del self._handle

    def current_max_word_length(self):
        return self._handle.current_max_word_length()

    def nr_idempotents(self):
        return self._handle.nr_idempotents()
    
    def is_done(self):
        return self._handle.is_done()
    
    def is_begun(self):
        return self._handle.is_begun()
    
    def current_position(self, Element x):
        pos = self._handle.current_position(x._handle)
        if pos == -1:
            return None # TODO Ok?
        return pos
    
    def __contains__(self, Element x):
        return self._handle.test_membership(x._handle)

    def set_report(self, val):
        if val == True:
            self._handle.set_report(1)
        else:
            self._handle.set_report(0)

    def factorisation(self, Element x):
        '''
        >>> import from semigroups *
        >>> S = FullTransformationMonoid(5)
        >>> S.factorisation(Transformation([0] * 5))
        [1, 0, 2, 1, 0, 2, 1, 0, 2, 1]
        >>> S[1] * S[0] * S[2] * S[1] * S[0] * S[2] * S[1] * S[0] * S[2] * S[1]
        '''
        pos = self._handle.position(x._handle)
        if pos == -1:
            return None # TODO Ok?
        cdef vector[size_t]* c_word = self._handle.factorisation(pos)
        assert c_word != NULL
        py_word = [letter for letter in c_word[0]]
        del c_word
        return py_word
    
    def enumerate(self, limit):
        self._handle.enumerate(limit)

    def size(self):
        """
        Return the size of this semigroup

        EXAMPLES::

            >>> from semigroups import Semigroup, Transformation
            >>> S = Semigroup([Transformation([1,1,4,5,4,5]),Transformation([2,3,2,3,5,5])])
            >>> S.size()
            5
        """
        # Plausibly wrap in sig_off / sig_on
        return self._handle.size()

    cdef new_from_handle(self, cpp.Element* handle):
        return self._an_element.new_from_handle(handle)

    def __getitem__(self, size_t pos):
        """
        Return the ``pos``-th element of ``self``.

        EXAMPLES::

            >>> from semigroups import Semigroup
            >>> S = Semigroup([1j])
            >>> S[0]
            1j
            >>> S[1]
            (-1+0j)
            >>> S[2]
            (-0-1j)
            >>> S[3]
            (1-0j)
        """
        cdef cpp.Element* element
        element = self._handle.at(pos)
        if element == NULL:
            return None
        else:
            return self.new_from_handle(element)

    def __iter__(self):
        """
        An iterator over the elements of self.

        EXAMPLES::

            >>> from semigroups import Semigroup
            >>> S = Semigroup([1j])
            >>> for x in S:
            ...     print(x)
            1j
            (-1+0j)
            (-0-1j)
            (1-0j)
        """
        cdef size_t pos = 0
        cdef cpp.Element* element
        while True:
            element = self._handle.at(pos)
            if element == NULL:
                break
            else:
                yield self.new_from_handle(element)
            pos += 1

def FullTransformationMonoid(n):
    assert isinstance(n, int) and n >= 1
    if n == 1: 
        return Semigroup(Transformation([0]))
    elif n == 2:
        return Semigroup(Transformation([1, 0]), Transformation([0, 0]))
    
    return Semigroup([Transformation([1, 0] + list(range(2, n))), 
                      Transformation([0, 0] + list(range(2, n))), 
                      Transformation([n - 1] + list(range(n - 1)))])

